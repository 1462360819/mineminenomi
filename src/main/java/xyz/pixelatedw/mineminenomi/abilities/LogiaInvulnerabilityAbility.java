package xyz.pixelatedw.mineminenomi.abilities;

import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.util.DamageSource;
import net.minecraft.util.ResourceLocation;
import xyz.pixelatedw.mineminenomi.abilities.haki.BusoshokuHakiFullBodyHardeningAbility;
import xyz.pixelatedw.mineminenomi.abilities.haki.BusoshokuHakiHardeningAbility;
import xyz.pixelatedw.mineminenomi.api.helpers.AbilityHelper;
import xyz.pixelatedw.mineminenomi.api.helpers.ItemsHelper;
import xyz.pixelatedw.mineminenomi.config.CommonConfig;
import xyz.pixelatedw.mineminenomi.data.entity.devilfruit.DevilFruitCapability;
import xyz.pixelatedw.mineminenomi.entities.projectiles.extra.KairosekiBulletProjectile;
import xyz.pixelatedw.mineminenomi.init.ModBlocks;
import xyz.pixelatedw.mineminenomi.particles.effects.ParticleEffect;
import xyz.pixelatedw.mineminenomi.particles.effects.common.LogiaParticleEffect;
import xyz.pixelatedw.wypi.APIConfig;
import xyz.pixelatedw.wypi.WyHelper;
import xyz.pixelatedw.wypi.abilities.Ability;
import xyz.pixelatedw.wypi.abilities.PassiveAbility;
import xyz.pixelatedw.wypi.abilities.projectiles.AbilityProjectileEntity;
import xyz.pixelatedw.wypi.data.ability.AbilityDataCapability;
import xyz.pixelatedw.wypi.data.ability.IAbilityData;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;

public class LogiaInvulnerabilityAbility extends PassiveAbility {

    ResourceLocation texture;
    private static ArrayList<DamageSource> invulnerableSources = new ArrayList<>(Arrays.asList(DamageSource.CACTUS, DamageSource.SWEET_BERRY_BUSH, DamageSource.ANVIL, DamageSource.FLY_INTO_WALL, DamageSource.FALL, DamageSource.FALLING_BLOCK));
    private DamageSource[] newSources;
    protected ILogiaEffect onSpecificLogiaEffect = (target, attacker) -> true;

    public LogiaInvulnerabilityAbility(ResourceLocation texture, ILogiaEffect effect, DamageSource... s) {
        super("Logia Intangibility " + WyHelper.getNameFromTexture(texture.toString()), APIConfig.AbilityCategory.DEVIL_FRUIT);
        this.texture = texture;
        System.out.println( WyHelper.getNameFromTexture(texture.toString()));
        if(effect != null) this.onSpecificLogiaEffect = effect;
        newSources = s;
        invulnerableSources.addAll(Arrays.asList(newSources));
    }

    public boolean damageReceived(LivingEntity entity, DamageSource damageSource) {
        boolean result = false;
        boolean attackerIsLogia = false;
        boolean instantAttackerHasKairosekiWeapon = false;
        Entity trueSource = damageSource.getTrueSource();
        Entity instantSource = damageSource.getImmediateSource();


        for (DamageSource s : invulnerableSources) {
            if (damageSource.equals(s)) {
                result = true;
                if(s.isFireDamage())
                    entity.extinguish();
                break;
            }
        }


        if(instantSource instanceof  LivingEntity) {
            ItemStack heldItem = ((LivingEntity) trueSource).getHeldItemMainhand();
            instantAttackerHasKairosekiWeapon = ItemsHelper.isKairosekiWeapon(heldItem);
        }

        boolean attackerHasHaki = false;
        if (trueSource instanceof LivingEntity) {
            IAbilityData attackerAbilityProps = AbilityDataCapability.get((LivingEntity) trueSource);
            Ability busoHaki = attackerAbilityProps.getEquippedAbility(BusoshokuHakiHardeningAbility.INSTANCE);
            boolean hasBusoHakiActive = (busoHaki != null && busoHaki.isContinuous());
            Ability fullBodyBusoHaki = attackerAbilityProps.getEquippedAbility(BusoshokuHakiFullBodyHardeningAbility.INSTANCE);
            boolean hasFullBodyBusoHakiActive = (fullBodyBusoHaki != null && fullBodyBusoHaki.isContinuous());
            attackerHasHaki = hasBusoHakiActive || hasFullBodyBusoHakiActive;

            attackerIsLogia = DevilFruitCapability.get((LivingEntity) trueSource).isLogia();
            if (kairosekiChecks(entity) || instantAttackerHasKairosekiWeapon || attackerHasHaki) return false;

            result = this.onSpecificLogiaEffect.attackerEffect(entity, (LivingEntity) trueSource);
        }


            if (instantSource instanceof KairosekiBulletProjectile ||
                    (CommonConfig.instance.isLogiaHurtsLogiasEnabled() && instantSource instanceof AbilityProjectileEntity && attackerIsLogia && !((AbilityProjectileEntity) instantSource).getPhysical()) ) {
                result = false;
            }

        if (damageSource.isExplosion()) result = true;


        if (result) {
            ParticleEffect particleEffect = new LogiaParticleEffect(this.texture);
            particleEffect.spawn(entity.world, entity.posX, entity.posY, entity.posZ, 0, 0, 0);
        }

        return result;
    }

    private static boolean kairosekiChecks(LivingEntity entity) {
        if (entity instanceof PlayerEntity) {
            PlayerEntity playerEntity = (PlayerEntity) entity;
            return AbilityHelper.isNearbyKairoseki(playerEntity);
        } else {
            return WyHelper.isBlockNearby(entity, 3, ModBlocks.KAIROSEKI, ModBlocks.KAIROSEKI_ORE, ModBlocks.KAIROSEKI_BARS);
        }
    }

    @Override
    public Ability create() {
        try
        {
            return this.getClass()
                    .getConstructor(ResourceLocation.class, ILogiaEffect.class, DamageSource[].class)
                    .newInstance(this.texture, this.onSpecificLogiaEffect, this.newSources);
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
        return null;
    }

    public interface ILogiaEffect extends Serializable {
        boolean attackerEffect(LivingEntity origin, LivingEntity attacker);
    }
}
